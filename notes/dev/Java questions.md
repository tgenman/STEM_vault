---
aliases:
created: 2025-10-16 13:19
parent:
  - "[[root dev questions]]"
connected:
  - "[[Kotlin questions]]"
  - "[[Spring questions]]"
tags:
---
TARGET DECK: stem::dev::java


START
math_basic_single
FRONT: Разница между TreeSet и HashSet
BACK: TreeSet — хранит элементы в отсортированном порядке (на основе Red-Black Tree); HashSet — без порядка, на основе хэш-таблицы.
ID: 1760610729987
END

START
math_basic_single
FRONT: Различие между интерфейсом и абстрактным классом
BACK: 
- Интерфейс описывает контракт; абстрактный класс — частичную реализацию.  
- Интерфейс не хранит состояние (кроме static/final полей); абстрактный класс может иметь обычные поля.  
- Класс может реализовывать несколько интерфейсов, но наследовать только один абстрактный класс.  
- Методы интерфейса по умолчанию public и abstract (или default/static/private в новых версиях).  
- Абстрактный класс может иметь конструкторы, интерфейс — нет.  
- Используй интерфейс для поведения, абстрактный класс — для общей логики и состояния.
ID: 1760610782506
END

START
math_basic_single
FRONT: Можно ли в Java переопределить статические методы?
BACK:
Нет, **статические методы нельзя переопределить** — они принадлежат классу, а не экземпляру.  
Если в подклассе объявить метод с тем же именем и сигнатурой, он **скрывает (hides)** метод родителя, но не переопределяет его.  
Вызов всегда определяется **по типу ссылки, а не по объекту**.  
```java
class A {
    static void print() { System.out.println("A"); }
}
class B extends A {
    static void print() { System.out.println("B"); }
}

A a = new B();
a.print(); // выведет "A"
```
ID: 1760612846024
END

START
math_basic_single
FRONT: Что такое _effective final_ в Java, зачем он нужен, как работает и что если ссылка на изменяемый объект?
BACK: _Effective final_ — это локальная переменная или параметр метода, значение которой после первого присвоения не изменяется, хотя она не объявлена как `final`. Компилятор отслеживает это по потоку данных: если нет повторных присваиваний, переменная считается _effective final_ и может использоваться в лямбдах и анонимных классах. При этом JVM копирует значение ссылки, а не объект — сам объект может изменяться. То есть неизменна ссылка, но не содержимое объекта.
ID: 1760612912398
END

